# 리덕스의 지켜야할 규칙

## 1. 하나의 애플리케이션 안에는 하나의 스토어가 존재합니다.

- 하나의 애플리케이션에는 단 한개의 스토어를 만들어서 사용해야 합니다.
- 여러개의 스토어를 사용할 수 있지만 권장하지는 않습니다.
  - 특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 분리할 때 여러개의 스토어를 만들게 됩니다.
  - 하지만 이럴 경우 개발도구를 활용할 수 없습니다.



## 2. 상태는 읽기전용이어야 합니다.

- 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트를 하게 되면 나중에 개발자 도구를 통해 뒤로 돌리거나 앞으로 돌릴 수 있습니다.
- 또한 불변성을 유지하는 이유는 리덕스는 내부적으로 데이터가 변경 되는 것을 감지하기 위해 **얕은 비교**를 진행하기 때문입니다.
  - 이를 통해 객체의 변화를 감지할 때 깊숙한 안쪽까지 비교하지 않고 겉에만 비교함으로써 좋은 성능을 유지할 수 있습니다.
- 불변성을 유지하기 위해 `immutable.js` 또는 `immer.js`를 많이 활용합니다.



## 3. 변화를 일으키는 함수인 리듀서는 순수한 함수여야 합니다.

- 순수함수로 만들어야하는 이유는 리덕스의 변경 감지 알고리즘 때문입니다.
  - 리덕스는 주어진 상태(객체)를 가져와서 loop의 각 리듀서에게 전달합니다.
  - 그리고 변경사항이 있는 경우 리듀서의 새로운 객체를 리턴하고 변경사항이 없으면 이전 객체를 리턴합니다.
  - 리덕스는 두 객체의 **메모리 위치**를 비교하여 이전 객체가 새 겍체와 동일한지 여부를 단순하게 체크합니다.
  - 만약 이전 객체의 속성이 변경되면 **새 상태 객체**와 **이전 객체**가 동일한 객체를 가르키게 되고 리덕스는 아무것도 변경되지 않았다고 판단합니다.
    - 시간 복잡도 : O(1)

- 순수한 함수 : 동알한 `input`은 언제나 동일한 `output`이어야 합니다. 또한 함수 내의 변수 외에 외부의 값을 참조, 의존하거나 변경하지 않아야 합니다.

  ```js
  let obj = {value: 30};
  
  // 바깥의 변수 obj의 값이 변경됨으로 순수함수가 아니다.
  const fn1 = (obj, b) => {
  	obj.value += b;
  }
  
  // 순수함수
  const fn2 = (obj, b) => {
  	return {value: obj.value + b}
  }
  ```

  - 리듀서 함수는 이전 상태와 액션 객체를 인자로 받습니다.
  - 이전 상태는 건들이지 않고 변화를 일으킨 새로운 상태 객체를 만들어서 반환합니다.
  - 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야만 합니다.

- 실행할 때마다 다른 결과값을 보여주게 된다면 리듀서 함수 바깥에서 처리해야 합니다.

  - 리덕스 미들웨어를 사용합니다.